"#\n# This files generates a proof for the correctness of \n#      the following envy-free cake-cutting protocol for four agents:\n#\n# A:Equalize(4) \n# One of:\n#    B:Equalize(2)\n#    B:Equalize(3)\n#    C:Equalize(2)\n#    C:Equalize(3)\n#\n\nload (\"Pref.sage\")\nload (\"Dict.sage\")\nload (\"Opts.sage\")\n\ndef filter_by_equalize2_failure_4pieces(space, dict, cutter, observers, cycles):\n    \"\"\"\n        space:     a string of spaces for display purposes.\n        dict:      a dictionary matching agents (letters) to Prefs.\n        cutter:    a lower-case letter representing the cutting agent, e.g. \"b\".\n        observers: a string representing the other agents, e.g. \"c\" or \"cd\".\n        cycles:    a location to put the cycles, if found.\n        \n        In Equalize(2), the cutter cuts his best piece (e.g, \"4\" becomes \"4b\"),\n            and equalizes it to his second best piece (e.g. \"4b\" and \"3\" become best).\n        If this fails, it means that the other agent prefers either \"4b\" or \"3\" over the other pieces.        \n    \"\"\"\n\n    whole_pieces = dict[cutter].chain;\n    trimmed_pieces = list(whole_pieces);  trimmed_pieces[-1]+=cutter\n    monotonicity_prefs = [ [trimmed_pieces[-1], whole_pieces[-1]] ]\n    whole_pieces_before_trimming = whole_pieces[-1:]\n    trimmed_pieces_after_trimming = trimmed_pieces[-1:]\n    equalized_pieces = trimmed_pieces[-2:]\n    title = space+cutter+\":Equalize(2) makes \"+cutter+\"'s best pieces: \"+(\"=\".join(equalized_pieces))\n\n    dict[cutter].equalities.append(equalized_pieces)\n    dict[cutter].calc_poset()\n    global_cover_relations = dict[cutter].global_cover_relations(trimmed_pieces_after_trimming)\n    if global_cover_relations:\n        title += \", so globally: \"+Pref.repr_inequalities(global_cover_relations)\n    dict['*'].inequalities += monotonicity_prefs + global_cover_relations\n\n    title += \". This\"\n    the_opts = []  # the conditions under which Equalize(2) failes.\n    for observer in observers:\n        observer_pref = dict[observer]\n        if observer_pref.is_best(whole_pieces[-2]):\n           return must_fail(title, [dict], observer) # since piece -2 is not cut\n        for i in [-1,-2]:\n            if observer_pref.may_be_best(whole_pieces[i], whole_pieces_before_trimming):\n                the_opts.append(dict_implied_by_best_piece({}, observer, trimmed_pieces, i))\n    return filter_opts(title, [dict], the_opts, cycles)\n    \n    \ndef filter_by_equalize3_failure_4pieces(space, dict, cutter, observers, cycles):\n    \"\"\"\n        space:     a string of spaces for display purposes.\n        dict:      a dictionary matching agents (letters) to Prefs.\n        cutter:    a lower-case letter representing the cutting agent, e.g. \"b\".\n        observers: a string representing the other agents, e.g. \"c\" or \"cd\".\n        cycles:    a location to put the cycles, if found.\n        \n        In Equalize(3), the cutter cuts his two best pieces (e.g, \"4\" becomes \"4bb\" and \"3\" becomes \"3bb\"),\n            and equalizes it to his third best piece (e.g. \"4bb\", \"3bb\" and \"2\" become best).\n        If this fails, it means that the other agent prefers either \"2\" or \"1\" over the other pieces.\n    \"\"\"\n\n    whole_pieces = dict[cutter].chain;\n    trimmed_pieces = list(whole_pieces);  trimmed_pieces[-1]+=cutter+cutter;   trimmed_pieces[-2]+=cutter+cutter; \n    floor_piece = whole_pieces[-3]\n    monotonicity_prefs = [ [trimmed_pieces[-1], whole_pieces[-1]+cutter] ,\n                           [trimmed_pieces[-2], whole_pieces[-2]       ] ]\n    whole_pieces_before_trimming = whole_pieces[-2:]\n    trimmed_pieces_after_trimming = trimmed_pieces[-2:]\n    equalized_pieces = trimmed_pieces[-3:]\n    title = space+cutter+\":Equalize(3) makes \"+cutter+\"'s best pieces: \"+(\"=\".join(equalized_pieces))\n\n    dict[cutter].equalities.append(equalized_pieces)\n    dict[cutter].calc_poset()\n    global_cover_relations = dict[cutter].global_cover_relations(trimmed_pieces_after_trimming)\n    if global_cover_relations:\n        title += \", so globally: \"+Pref.repr_inequalities(global_cover_relations)\n    dict['*'].inequalities += monotonicity_prefs + global_cover_relations\n    \n    title += \". This\"\n    the_opts = []\n    for observer in observers:\n        observer_pref = dict[observer]\n        for i in [0,1]:        \n            if observer_pref.is_best(whole_pieces[i]):\n               return must_fail(title, [dict], observer) # since these two pieces are not cut\n            if observer_pref.may_be_best(whole_pieces[i], whole_pieces_before_trimming):\n               the_opts.append(dict_implied_by_best_piece({}, observer, trimmed_pieces, i))\n    return filter_opts(title, [dict], the_opts, cycles)\n    \ndef prove_4pieces_for_given_orders(b_order, c_order):\n    dict_0 = {'b': Pref(chain=b_order), 'c':Pref(chain=c_order), '*':Pref()}\n\n    opts_1 = filter_by_equalize2_failure_4pieces(\" \"*2, dict_0, cutter=\"b\",observers=\"c\",cycles=None)\n    if not opts_1: return None\n\n    for dict_1 in opts_1:\n        print_dict_explanation(dict_1, \" \"*3)\n        opts_2 = filter_by_equalize2_failure_4pieces(\" \"*4, dict_1, cutter=\"c\",observers=\"b\",cycles=None)\n        if not opts_2: continue\n\n        for dict_2 in opts_2:\n            print_dict_explanation(dict_2, \" \"*5)\n            opts_3 = filter_by_equalize3_failure_4pieces(\" \"*6, dict_2, cutter=\"b\",observers=\"c\", cycles=None)\n            if not opts_3: continue\n            \n            for dict_3 in opts_3:\n                print_dict_explanation(dict_3, \" \"*7)\n                opts_4 = filter_by_equalize3_failure_4pieces(\" \"*8, dict_3, cutter=\"c\",observers=\"b\", cycles=None)\n                if not opts_4: continue\n\n                print \"Failure!\"\n                print dict_3\n                print opts_4\n                raise Exception(\"Not proved!\")\n\ndef prove_4pieces():\n    a_pieces = [\"1\",\"2\",\"3\",\"4\"]\n    print \"Initially, agent a cuts four equal pieces: \", \",\".join(a_pieces),\".\"\n    \n    b_orders = [a_pieces]\n    c_orders = Poset([a_pieces,[]]).linear_extensions()\n    num_of_c_orders = len(c_orders)\n    \n    for b_order in b_orders: \n        print \"Assume w.l.o.g. that b's preferences are\", Pref.repr_chain(b_order), \".\"\n        print \"Consider the following\",num_of_c_orders,\"cases regarding the preferences of c:\"\n        for index_c,c_order in enumerate(c_orders):\n            print \"\\nCASE\",(index_c+1),\"OF\",num_of_c_orders, \\\n                  \": c's order is\", Pref.repr_chain(c_order),\":\"\n            \n            prove_4pieces_for_given_orders(b_order, c_order)\n    print \"\\nQ.E.D!\"\n"
{"patch":[[[[0,"+\"'s best pieces"],[1," are"],[0,": \"+(\"=\".join(eq"]],1404,1404,32,36]],"time":1446929036916}
{"patch":[[[[0,"ualize(2) makes "],[1," that "],[0,"\"+cutter+\"'s bes"]],1380,1380,32,38]],"time":1446929034915}
{"patch":[[[[0,"ize(2) m"],[-1,"akes "],[0," that \"+"]],1383,1383,21,16]],"time":1446929032920}
{"patch":[[[[0,"ize(2) m"],[1,"eans"],[0," that \"+"]],1383,1383,16,20]],"time":1446929030961}
{"patch":[[[[0,"t pieces"],[1," are"],[0,": \"+(\"=\""]],3705,3705,16,20]],"time":1446929023130}
{"patch":[[[[0,"3) m"],[-1,"akes"],[1,"ean"],[0," \"+c"]],3680,3680,12,11]],"time":1446929018123}
{"patch":[[[[0,"(3) mean"],[1,"s"],[0," \"+cutte"]],3679,3679,16,17]],"time":1446929016120}
{"patch":[[[[0,") means "],[1," "],[0,"\"+cutter"]],3681,3681,16,17]],"time":1446929013350}
{"patch":[[[[0,") means "],[1,"that"],[0," \"+cutte"]],3681,3681,16,20]],"time":1446929010441}
{"patch":[[[[0,"\nload (\""],[1,"/home/erelsgl/git/envy-free/"],[0,"Opts.sag"]],272,272,16,44]],"time":1446581230627}
{"patch":[[[[0,"\nload (\""],[1,"/home/erelsgl/git/envy-free/"],[0,"Dict.sag"]],253,253,16,44]],"time":1446581228624}
{"patch":[[[[0,"\nload (\""],[1,"/home/erelsgl/git/envy-free/"],[0,"Pref.sag"]],234,234,16,44]],"time":1446581226621}
{"patch":[[[[0,"e(3)\n#\n\n"],[1,"#"],[0,"load (\"/"]],227,227,16,17]],"time":1446581223592}