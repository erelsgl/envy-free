"#\n# The Dict class represents Prefs of different agents.\n#     It is like a dictionary that matches the agent's letter to its Pref.\n# \n# A Dict contains a key for every agent: 'b','c','d'... and two special keys:\n#    '?': text explanation;\n#    '*': relations that are true for ALL agents.\n#\n# Author: Erel Segai-Halevi\n# Date:   2015-10\n#\n\ndef and_dicts(dict1, dict2):\n    \"\"\"\n       returns an elementwise-concatenation of the given dictionaries (which represents an AND operation).\n    \"\"\"\n    new_dict = {}\n    for agent,pref in dict1.iteritems():\n        new_dict[agent] = copy(pref)\n    for agent,pref in dict2.iteritems():\n        #print agent,pref\n        if new_dict.has_key(agent):\n            if agent=='?':\n                new_dict[agent] += pref\n            else:\n                if isinstance(new_dict[agent],list):\n                    raise AttributeError(\"new_dict[\"+agent+\"] is list! \"+str(new_dict[agent]))\n                new_dict[agent].and_with(pref)\n        else:\n            new_dict[agent] = copy(pref)\n    return new_dict\n    \ndef dict_to_posets(dict, debug=None):\n    \"\"\"\n        dict is a dictionary of prefs.\n        The returned value is a dictionary of posets.\n    \"\"\"\n    the_dict_of_posets = {}\n    global_pref = dict['*']\n    for agent,pref in dict.iteritems():\n        if agent!='?' and agent!='*':\n            the_dict_of_posets[agent] = pref.calc_poset(global_pref)\n    return the_dict_of_posets\n    \ndef dict_cycles(dict):\n    \"\"\" \n       Returns a dict with the cycles in each pref in this dict (if any) \n       \n       EXAMPLES::       \n    \n       sage: dict_cycles({'a':Pref([[2,1],[3,4]]), 'b':Pref([[1,2]]), '*':Pref([[2,1]]), '?': [\"cycle test\"]})    \n       {'?': 'cycle test', 'b': '1<2<1'}\n    \"\"\"\n    the_dict_of_cycles = {}\n    global_pref = dict['*']\n    for agent,pref in dict.iteritems():\n        if agent!='?' and agent!='*':\n            cyc = pref.cycle(global_pref)\n            if cyc:\n                the_dict_of_cycles[agent] = Pref.repr_chain(cyc)\n    \n    if the_dict_of_cycles and dict.has_key('?'):\n       the_dict_of_cycles['?'] = \", \".join(dict['?'])  # keep the explanations\n\n    return the_dict_of_cycles\n\n\ndef dict_implied_by_best_piece(base_dict, agent, pieces, best_piece_index):\n    \"\"\"\n       EXAMPLES::\n       \n       sage: dict_implied_by_best_piece({'*':[]}, \"b\", [\"1\",\"2\",\"3\"], -1)\n       {'*': [], '?': ['b prefers 3 to 1 2'], 'b': 1<3 2<3 }\n    \"\"\"\n    best_piece = pieces[best_piece_index]\n    dominated_pieces = Pref.dominated_pieces(pieces, best_piece_index)\n    base_dict['?'] = [agent+\" prefers \"+best_piece+\" to \"+(\" \".join(dominated_pieces))]\n    base_dict[agent] = Pref ( inequalities = \n       [[dominated_piece, best_piece] for dominated_piece in dominated_pieces] )\n    return base_dict\n\ndef dict_interesting_global_inequalities(self):\n    if not self.has_key('*'):\n        return None\n    return self['*'].interesting_global_inequalities()\n\ndef print_dict_explanation(self, space):\n    if self.has_key('?'):\n        global_inequalities = dict_interesting_global_inequalities(self)\n        #if not global_inequalities:\n        print space+\"Assume the case   \" + self['?'][-1] + \". Then:\"\n        #else:\n        #   print space+\"Assume the case   \" + self['?'][-1] + \". Then globally: \"+global_inequalities+\". Then:\"\n       \n\ndef Dict_examples():\n    # EXAMPLE (expected: {'?': ['dict1', 'dict2'], 'a': 1<2 5<6, 'b': 3<4, 'c': 7<8})\n    print and_dicts({'a':Pref([[1,2]]), 'b':Pref([[3,4]]), '?': ['dict1']}, \n          {'a':Pref([[5,6]]), 'c':Pref([[7,8]]), '?': ['dict2']})    \n          \n    # EXAMPLE (expected: {'a': 1<2, 'b': 3<4})\n    print and_dicts({'a':Pref([[1,2]]), 'b':Pref([[3,4]])}, {'b': Pref([])})\n \n    # EXAMPLE (expected: {'a': Finite poset containing 6 elements, 'b': Finite poset containing 4 elements})\n    print dict_to_posets({'a':Pref([[1,2],[3,4]]), 'b':Pref([[1,2]]), '*':Pref([[5,6]])})\n    \n    # EXAMPLE (expected: ValueError: The graph is not directed acyclic)\n    #print dict_to_posets({'a':Pref([[1,2],[3,4]]), 'b':Pref([[1,2]]), '*':Pref([[2,1]])})\n   \n"
{"patch":[[[[0,"5-10\n#\n\n"],[1,"load (\"/home/erelsgl/git/envy-free/Pref.sage\")\n\n"],[0,"def and_"]],334,334,16,64]],"time":1446581260944}